import React, { useState, useEffect, useRef } from "react";
import Desmos from "desmos";

const lessons = {
  basics: {
    title: "Quadratic Basics",
    content: `Quadratics are second-degree polynomial equations. They can be written in many different forms, however the most prominent of them is the standard form, which is f(x) = ax² + bx + c. When they are graphed, they produce a parabola, which is a symmetrical curved shape that has only one minimum or maximum point, which is called the vertex.

In f(x) = ax² + bx + c, 
• a, b, and c are coefficients
• a determines the width of the parabola, and whether it is concave up or concave down
• b determines the horizontal shift of the parabola
• c is the y-intercept 

If a > 0, then the parabola would face upwards, and if a < 0, the parabola would face downwards. If a = 0, then that cancels out the x², therefore not making this a quadratic function, causing a linear line.

f(x) = x² is the parent function, where the parabola’s vertex and y-intercept are at 
(0, 0).`
  },
  standardForm: {
    title: "Standard Form",
    content: `The standard form of quadratic functions is f(x) = ax² + bx + c. This is the “base” or “expanded” quadratic function form, from which the following can be extracted: ‘a’ value, ‘b’ value, ‘c’ value (y-intercept), axis of symmetry, discriminant, and the quadratic formula.`
  },
  Factorization: {
    title: "Factorization",
    content: `Finding the x-intercepts, or roots, of a quadratic function requires factoring the equation. This provides insight on where the parabola intersects the x-axis, which helps in graphing the quadratic function.`
  },
  rootsForm: {
    title: "Roots Form",
    content: `The factored form, or roots form, is the factored version of the standard form. The roots form is f(x) = a(x - p) (x - q). This form is the easiest form to extract the roots / x-intercepts from, as the roots are just p & q. When expanded, it becomes the standard form.`
  },
  vertexForm: {
    title: "Vertex Form",
    content: `The vertex form, f(x) = a(x - h)² + k, is the easiest form to extract the vertex from, as the vertex is (h, k). This form also makes it easy to complete the square.`
  },
  quadraticFormula: {
    title: "Quadratic Formula",
    content: `The quadratic formula is the ultimate tool to solve any quadratic equation: 

x = [-b ± (b² - 4ac)] / 2a

It works on all quadratic equations, even when factoring is impossible. Just plug in values for a, b, and c from your equation in standard form (y = ax² + bx + c).

Example: Solve x² - 3x + 2 = 0
• a = 1, b = -3, c = 2
• x = [-(-3) ± ((-3)² - 4(1)(2))] / 2(1)
• x = [3 ± (9 - 8)] / 2
• x = [3 ± 1] / 2
• x = 1 or x = 2

Clean, simple, and reliable — this formula handles everything.`
  },
  discriminant: {
    title: "Discriminant",
    content: `The discriminant is the part of the quadratic formula under the square root: D = b² - 4ac. It tells you the nature and number of solutions of a quadratic equation.

- If D > 0 → Two real and distinct solutions
- If D = 0 → One real, repeated solution (a perfect square)
- If D < 0 → No real solutions (imaginary roots)

Example: y = x² + 4x + 4
• D = 4² - 4(1)(4) = 16 - 16 = 0 → One real solution

This value is quick to calculate and gives a snapshot of what kind of roots to expect — before doing any hard math. It’s a powerful pre-check for solving methods.`
  },
  disguisedQuadratic: {
    title: "Disguised Quadratics",
    content: `Some equations don’t look like quadratics at first glance but can be rewritten into quadratic form.

Example: x⁴ - 5x² + 6 = 0
Let u = x²
Then: u² - 5u + 6 = 0 → (u - 2)(u - 3) = 0
So u = 2 or u = 3 → x² = 2 or x² = 3 → x = ±√2, ±√3

These equations often show up in algebra and advanced math problems. Spotting the quadratic structure in disguise is a skill — if you can do it, you’re a step ahead of the game.`
  }
};

function GraphingCalculator() {
  const calculatorRef = useRef(null);
  const containerRef = useRef(null);

  useEffect(() => {
    const elt = containerRef.current;
    calculatorRef.current = Desmos.GraphingCalculator(elt, { expressions: true });
    return () => calculatorRef.current?.destroy();
  }, []);

  return (
    <div className="mt-6 mb-10">
      <div ref={containerRef} style={{ width: "100%", height: "400px" }} className="rounded-lg shadow-md border" />
    </div>
  );
}

function solveQuadratic(a, b, c) {
  const disc = b * b - 4 * a * c;
  let steps = "Discriminant = b² - 4ac = " + b + "² - 4×" + a + "×" + c + " = " + disc + "<br>";

  if (disc < 0) {
    steps += "No real roots (Discriminant < 0).";
  } else if (disc === 0) {
    const root = (-b / (2 * a)).toFixed(2);
    steps += `x = (-${b}) / (2×${a})<br>`;
    steps += `x = ${root}<br>`;
    steps += `One real solution: x = ${root}`;
  } else {
    const root1 = (-b + Math.sqrt(disc)) / (2 * a);
    const root2 = (-b - Math.sqrt(disc)) / (2 * a);
    steps += `x = (-${b} ± √${disc}) / (2×${a})<br>`;
    steps += `x = (${(-b)} ± ${Math.sqrt(disc).toFixed(2)}) / ${2 * a}<br>`;
    steps += `Solutions: x₁ = ${root1.toFixed(2)}, x₂ = ${root2.toFixed(2)}`;
  }

  return steps;
}

function solveForCoefficient(x, y, a, b, c, form) {
  switch (form) {
    case "standard":
      if (a === "?" && !isNaN(b) && !isNaN(c)) return (y - b * x - c) / (x * x);
      if (b === "?" && !isNaN(a) && !isNaN(c)) return (y - a * x * x - c) / x;
      if (c === "?" && !isNaN(a) && !isNaN(b)) return y - a * x * x - b * x;
      break;
    default:
      return "Unsupported form or missing input.";
  }
}

export default function QuadraticSite() {
  const [activeLesson, setActiveLesson] = useState("basics");
  const [solverA, setSolverA] = useState("");
  const [solverB, setSolverB] = useState("");
  const [solverC, setSolverC] = useState("");
  const [output, setOutput] = useState("");
  const [coefA, setCoefA] = useState("");
  const [coefB, setCoefB] = useState("");
  const [coefC, setCoefC] = useState("");
  const [xPoint, setXPoint] = useState("");
  const [yPoint, setYPoint] = useState("");
  const [coefOutput, setCoefOutput] = useState("");

  const handleSolve = () => {
    const aNum = parseFloat(solverA);
    const bNum = parseFloat(solverB);
    const cNum = parseFloat(solverC);

    if (isNaN(aNum) || isNaN(bNum) || isNaN(cNum)) {
      setOutput("👀 Enter real numbers, genius.");
      return;
    }

    setOutput(solveQuadratic(aNum, bNum, cNum));
  };

  const handleCoefficientSolve = () => {
    const x = parseFloat(xPoint);
    const y = parseFloat(yPoint);
    const aVal = coefA === "?" ? "?" : parseFloat(coefA);
    const bVal = coefB === "?" ? "?" : parseFloat(coefB);
    const cVal = coefC === "?" ? "?" : parseFloat(coefC);

    if (isNaN(x) || isNaN(y)) {
      setCoefOutput("Provide a valid point (x, y).");
      return;
    }

    const result = solveForCoefficient(x, y, aVal, bVal, cVal, "standard");
    setCoefOutput(`Solved coefficient: ${result}`);
  };

  return (
    <div className="flex min-h-screen bg-gray-50 text-gray-800">
      <aside className="w-64 bg-white border-r shadow-lg p-4">
        <h2 className="text-2xl font-bold mb-6">Lessons</h2>
        <ul className="space-y-2">
          {Object.entries(lessons).map(([key, value]) => (
            <li key={key}>
              <button
                onClick={() => setActiveLesson(key)}
                className={`w-full text-left px-3 py-2 rounded-lg text-lg transition-colors duration-200 ${
                  activeLesson === key ? "bg-blue-100 text-blue-800 font-semibold" : "hover:bg-gray-100"
                }`}
              >
                {value.title}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      <main className="flex-1 p-8 relative">
        <h1 className="text-4xl font-bold text-center mb-8">Quadratic Mastery</h1>
        <GraphingCalculator />

        <div className="bg-white rounded-lg shadow-lg p-6 text-xl leading-relaxed">
          <h2 className="text-2xl font-bold mb-4">{lessons[activeLesson]?.title}</h2>
          <div className="whitespace-pre-line">{lessons[activeLesson]?.content}</div>
        </div>

        <div className="mt-10 bg-white p-6 rounded-lg shadow-md text-lg">
          <h3 className="text-xl font-semibold mb-4">Really stuck? Use the Quadratic Solver:</h3>
          <input value={solverA} onChange={(e) => setSolverA(e.target.value)} placeholder="a" className="border px-3 py-2 mr-2" />
          <input value={solverB} onChange={(e) => setSolverB(e.target.value)} placeholder="b" className="border px-3 py-2 mr-2" />
          <input value={solverC} onChange={(e) => setSolverC(e.target.value)} placeholder="c" className="border px-3 py-2 mr-2" />
          <button onClick={handleSolve} className="bg-blue-600 text-white px-4 py-2 rounded">Solve</button>
          <div className="mt-4 text-base" dangerouslySetInnerHTML={{ __html: output }}></div>
        </div>

        <div className="mt-10 bg-white p-6 rounded-lg shadow-md text-lg">
          <h3 className="text-xl font-semibold mb-4">Missing a coefficient? Let’s solve for it:</h3>
          <p className="mb-2">Leave the unknown coefficient as a question mark ("?").</p>
          <input value={coefA} onChange={(e) => setCoefA(e.target.value)} placeholder="a" className="border px-3 py-2 mr-2" />
          <input value={coefB} onChange={(e) => setCoefB(e.target.value)} placeholder="b" className="border px-3 py-2 mr-2" />
          <input value={coefC} onChange={(e) => setCoefC(e.target.value)} placeholder="c" className="border px-3 py-2 mr-2" />
          <input value={xPoint} onChange={(e) => setXPoint(e.target.value)} placeholder="x (known point)" className="border px-3 py-2 mr-2" />
          <input value={yPoint} onChange={(e) => setYPoint(e.target.value)} placeholder="y (known point)" className="border px-3 py-2 mr-2" />
          <button onClick={handleCoefficientSolve} className="bg-green-600 text-white px-4 py-2 rounded">Solve Coefficient</button>
          <div className="mt-4 text-base">{coefOutput}</div>
        </div>
      </main>
    </div>
  );
}
